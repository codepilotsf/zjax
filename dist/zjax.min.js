window.zjax=getGlobalZjaxObject();const httpMethods=["GET","POST","PUT","PATCH","DELETE"];const swapTypes=["outer","inner","before","after","prepend","append","none","delete"];const isVTSupported=document.startViewTransition!==undefined;addEventListener("DOMContentLoaded",(function(){debug("Parsing DOM");parseZSwaps(document)}));function getGlobalZjaxObject(){return{debug:false,transitions:true,zjaxActions:{},userActions:{},actions:function(arg1,arg2){const namespace=arg2?arg1:null;if(namespace==="zjax"){throw new Error("'zjax' is a reserved actions namespace")}const object=arg2?arg2:arg1;let userActionsTarget;if(namespace){this.userActions[namespace]={};userActionsTarget=this.userActions[namespace]}else{userActionsTarget=this.userActions}Object.keys(object).forEach((function(name){const actionFunction=object[name];userActionsTarget[name]=actionFunction}))}}}async function parseZSwaps(documentOrNode){const zSwapNodes=getMatchingNodes(documentOrNode,"[z-swap]");debug(`Found ${zSwapNodes.length} z-swap nodes in ${prettyNodeName(documentOrNode)}`);for(const node of zSwapNodes){try{zSwapString=node.getAttribute("z-swap");const zSwapObject=getZSwapObject(zSwapString,node);const zSwapFunction=getZSwapFunction(zSwapObject,node);attachEventListener(zSwapObject.trigger,zSwapFunction,node);attachMutationObserver(zSwapObject.trigger,zSwapFunction,node);zjax.debug&&debug(`Added z-swap for '${zSwapObject.trigger}' events to ${prettyNodeName(node)}`)}catch(error){console.error(`ZJAX ERROR – Unable to parse z-swap: ${error.message}\n`,node)}}}function getZSwapObject(zSwapString,node){const valueString=collapseCommas(zSwapString);const valueParts=valueString.split(/\s/);if(valueParts.length<1||valueParts.length>4){throw new Error("Must have between 1 and 4 parts separated by spaces.")}const zSwapObject={};const leftoverParts=[];while(valueParts.length>0){const part=valueParts.shift();const typeAndValue=getTriggerMethodOrEndpointPair(part);if(typeAndValue){zSwapObject[typeAndValue[0]]=typeAndValue[1]}else{leftoverParts.push(part)}}zSwapObject.swaps=getSwaps(leftoverParts.join(" "));if(!zSwapObject.trigger){zSwapObject.trigger=node.tagName==="FORM"?"submit":"click"}if(!zSwapObject.method){zSwapObject.method=node.tagName==="FORM"?"POST":"GET"}if(!zSwapObject.endpoint){if(node.tagName==="FORM"){zSwapObject.endpoint=node.action}else if(node.tagName==="A"){zSwapObject.endpoint=node.href}else{throw new Error("No endpoint inerrable or specified")}}return zSwapObject}function getTriggerMethodOrEndpointPair(swapSpecifier){if(swapSpecifier.startsWith("@")){return["trigger",swapSpecifier.substr(1)]}if(httpMethods.includes(swapSpecifier.toUpperCase())){return["method",swapSpecifier.toUpperCase()]}regexEndpoint=/^(\/.*|\.\/.*|https?:\/\/.*|\.)$/;if(regexEndpoint.test(swapSpecifier)){return["endpoint",swapSpecifier]}}function prettyNodeName(documentOrNode){return documentOrNode instanceof Document?"#document":"<"+documentOrNode.tagName.toLowerCase()+(documentOrNode.id?"#"+documentOrNode.id:"")+">"}function getMatchingNodes(documentOrNode,selector){const nodesToParse=[];nodesToParse.push(...documentOrNode.querySelectorAll(selector));const isDocument=documentOrNode instanceof Document;if(!isDocument&&documentOrNode.matches(selector)){nodesToParse.push(documentOrNode)}return nodesToParse}function getSwaps(swapString){const swaps=[];swapString.split(",").forEach((function(swapPart){const swap={};const responseAndTargetSwaps=swapPart.split("->");const targetAndSwapType=responseAndTargetSwaps.pop();const[targetNode,swapType]=targetAndSwapType.split("|");const responseNode=responseAndTargetSwaps[0]||targetNode;swap["response"]=responseNode;swap["target"]=targetNode;swap["swapType"]=swapType||"outer";if(swap["swapType"]&&!swapTypes.includes(swap["swapType"])){throw new Error(`Invalid swap type: ${swap["swapType"]}`)}swaps.push(swap)}));return swaps}function getZSwapFunction(zSwap,node){return async function(event){event.preventDefault();event.stopPropagation();debug("z-swap triggered for",zSwap);try{const responseDOM=await getResponseDOM(zSwap.method,zSwap.endpoint);zSwap.swaps.forEach((function(swap){const[responseNode,targetNode]=getNewAndOldNodes(responseDOM,swap);debug(`Parsing incoming response for z-swaps`);parseZSwaps(responseNode);if(isVTSupported&&zjax.transitions){document.startViewTransition((()=>{swapOneNode(targetNode,responseNode,swap.swapType)}))}else{swapOneNode(targetNode,responseNode,swap.swapType)}}))}catch(error){console.error(`ZJAX ERROR – Unable to execute z-swap function: ${error.message}\n`,node,error.stack)}}}async function getResponseDOM(method,endpoint){const response=await fetch(endpoint,{method:method,body:null});if(!response.ok){throw new Error(`${response.status} ${response.statusText} for ${endpoint}`)}const responseDOM=(new DOMParser).parseFromString(await response.text(),"text/html");debug(`z-swap response from ${endpoint} received and parsed`);return responseDOM}function getNewAndOldNodes(responseDOM,swap){let targetNode;let responseNode;if(swap.target==="*"){targetNode=document.querySelector("body");if(!targetNode){throw new Error("Unable to find body element in local DOM to swap into")}}else{targetNode=document.querySelector(swap.target)}responseNode=swap.response==="*"?responseDOM:responseDOM.querySelector(swap.response);if(!targetNode&&swap.swapType!=="none"){throw new Error(`Target node '${swap.target}' does not exist in local DOM`)}if(!responseNode&&swap.swapType!=="none"&&swap.swapType!=="delete"){throw new Error(`Source node ${swap.response} does not exist in response DOM`)}return[responseNode,targetNode]}function swapOneNode(targetNode,responseNode,swapType){const responseNodes=normalizeNodeList(responseNode);if(swapType==="outer"){const targetNodeParent=targetNode.parentNode;responseNodes.forEach((item=>{targetNodeParent.insertBefore(item,targetNode)}));targetNodeParent.removeChild(targetNode);return}if(swapType==="inner"){targetNode.textContent="";responseNodes.forEach((item=>{targetNode.appendChild(item)}));return}if(swapType==="before"){responseNodes.forEach((item=>{targetNode.parentNode.insertBefore(item,targetNode)}));return}if(swapType==="after"){const parentNode=targetNode.parentNode;referenceNodeToAppendTo=targetNode;responseNodes.forEach((item=>{if(item===parentNode.lastChild){parentNode.appendChild(item)}else{parentNode.insertBefore(item,referenceNodeToAppendTo.nextSibling)}referenceNodeToAppendTo=item}));return}if(swapType==="prepend"){const firstChild=targetNode.firstChild;responseNodes.forEach((item=>{if(firstChild){targetNode.insertBefore(item,firstChild)}else{targetNode.appendChild(item)}}));return}if(swapType==="append"){responseNodes.forEach((item=>{targetNode.appendChild(item)}));return}if(swapType==="delete"){targetNode.remove();return}if(swapType==="none"){return}}function normalizeNodeList(node){if(node instanceof Document){const htmlNode=node.querySelector("html");if(htmlNode){return Array.from(htmlNode.childNodes)}const fragment=document.createDocumentFragment();for(const child of node.childNodes){fragment.appendChild(child)}return Array.from(fragment.childNodes)}if(node instanceof NodeList||Array.isArray(node)){return Array.from(node)}return[node]}function attachEventListener(trigger,handler,node){node.addEventListener(trigger,handler)}function attachMutationObserver(trigger,handler,node){const observer=new MutationObserver((mutationsList=>{for(const mutation of mutationsList){for(const removedNode of mutation.removedNodes){if(removedNode===node||removedNode.contains(node)){node.removeEventListener(trigger,handler);zjax.debug&&debug(`Removing event listener for ${prettyNodeName(node)} (no longer in DOM)`);observer.disconnect();return}}}}));observer.observe(document.body,{childList:true,subtree:true})}function collapseCommas(str){return str.replace(/\s*,\s*/g,",")}function debug(){if(!zjax.debug){return}console.log("ZJAX DEBUG:",...arguments)}